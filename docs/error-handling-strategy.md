# Error Handling Strategy\n\nThis document outlines the error handling strategy for the `roborail-assistant` project, focusing on providing user-friendly (API-level) messages while ensuring comprehensive internal logging for debugging and auditing.\n\n## Core Principles\n\n1.  **Detailed Internal Logging:** All errors caught within service operations must be logged with sufficient detail to aid in debugging and auditing. This includes:\n    *   The original error object (message and stack trace if available).\n    *   Contextual information relevant to the operation (e.g., `userId`, `documentId`, `conversationId`, key request parameters).\n    *   A clear, operation-specific prefix message (e.g., \"Failed to process chat message\").\n    *   This is handled using Encore\'s structured logger: `logger.error(error, prefixMessage, { context })`.\n\n2.  **Informative API Error Responses:** Errors thrown from API endpoints should provide enough information for the frontend to display a meaningful message to the user, without exposing internal implementation details or sensitive information.\n    *   The standard pattern is to throw a new `Error` instance.\n    *   The message for this new error combines a user-friendly (for API context) prefix with the message from the original error if it\'s an `instanceof Error`. Example: `throw new Error(prefixMessage + (originalError instanceof Error ? \`: ${originalError.message}` : \': Unknown error\'));`\n\n3.  **Frontend Responsibility for User-Facing Messages:** The frontend application is responsible for interpreting the API error responses and presenting the final, polished error message to the end-user in the UI. The API provides a balance of clarity and safety in its error responses.\n\n4.  **Consistency:** Strive for consistent prefix messages for similar types of errors across different services to aid the frontend in categorizing and handling them.\n\n## Standard `catch` Block Pattern\n\nThe typical pattern for handling errors in service operations is as follows:\n\n```typescript\n// Inside an async API endpoint or service function\ntry {\n  // ... operation logic ...\n} catch (error) {\n  const descriptivePrefix = \"A clear, operation-specific error prefix (e.g., \'Failed to retrieve document\')\";\n  \n  // Log detailed error internally\n  if (error instanceof Error) {\n    logger.error(error, descriptivePrefix, { /* relevant context like userId, documentId, requestParams */ });\n  } else {\n    // Handle cases where the caught error might not be an Error instance\n    logger.error(descriptivePrefix, { /* relevant context */, errorDetails: error });\n  }\n  \n  // Throw a new error for the API response\n  // This message is intended for the frontend to interpret\n  let apiErrorMessage = descriptivePrefix;\n  if (error instanceof Error && error.message) {\n    // Append original error message if it\'s considered safe and informative for API consumer\n    // Avoid appending overly technical or sensitive internal error messages directly.\n    // If original error.message is too revealing, consider a more generic addition or none.\n    apiErrorMessage += `: ${error.message}`;\n  } else {\n    apiErrorMessage += \": An unexpected error occurred.\";\n  }\n  throw new Error(apiErrorMessage);\n}\n```\n\n## Review of API Error Message Prefixes\n\n(Refer to the list compiled in the plan for Task 13.3 in Taskmaster for existing prefixes across services like `chat`, `upload`, `docprocessing`, `docmgmt`.)\n\nThese prefixes should be reviewed periodically for clarity and consistency.\n\n## Security Considerations\n\n*   Ensure that error messages propagated to the API response (and thus potentially to the frontend) do **not** include sensitive information like file paths, database queries, stack traces, or internal configuration details.\n*   Detailed stack traces and sensitive context should only be present in the internal logs, accessible to developers and system administrators.\n\nThis strategy aims to balance the need for robust internal logging with the provision of helpful, yet secure, error information to API consumers and, ultimately, end-users.\n 