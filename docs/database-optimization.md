# Database Optimization Strategy\n\nThis document outlines the strategy for database query optimization and indexing within the `roborail-assistant` project to ensure performance and scalability.\n\n## Query Optimization Approach\n\n1.  **Identify Critical Queries:** Focus on read-heavy operations in user-facing APIs and write-heavy operations that could become bottlenecks.\n    *   `chat/conversation-management.ts`: `listConversations`, `getConversation`.\n    *   `docmgmt/documents.ts`: `getDocuments` (especially with filters and search), `getDocumentChunks`.\n    *   `docprocessing/processing.ts`: `storeChunksInDatabase` (bulk inserts).\n\n2.  **Analysis Techniques (Conceptual):**\n    *   **Query Structure Review:** Examine Drizzle ORM query constructions for potential inefficiencies (e.g., N+1 problems if not using relational queries correctly, overly complex joins, or inefficient filtering logic).\n    *   **Indexing Strategy:** Prioritize indexing columns used in `WHERE` clauses, `JOIN` conditions, and `ORDER BY` clauses.\n    *   **Data Skew & Cardinality:** Consider the potential for data skew and cardinality of indexed columns, though this requires actual data analysis beyond static code review.\n\n3.  **Optimization Implementation:**\n    *   Utilize Drizzle ORM features for efficient querying (e.g., relational queries for joins, batch operations for bulk inserts/updates).\n    *   Implement appropriate indexes in `backend/db/schema.ts`.\n\n## Implemented and Proposed Indexes (`backend/db/schema.ts`)\n\n### `documents` Table\n*   **Existing:**\n    *   `userIdIdx: index(\"documents_user_id_idx\").on(table.userId)`\n    *   `statusIdx: index(\"documents_status_idx\").on(table.status)`\n    *   `uploadedAtIdx: index(\"documents_uploaded_at_idx\").on(table.uploadedAt)`\n*   **Added/Proposed (Task 14.2):**\n    *   `filenameLowerIdx: index(\"documents_filename_lower_idx\").on(sql\`lower(${table.filename})\`)` - For case-insensitive search on `filename`.\n    *   `originalNameLowerIdx: index(\"documents_original_name_lower_idx\").on(sql\`lower(${table.originalName})\`)` - For case-insensitive search on `originalName`.\n    *   `metadataTitleLowerIdx: index(\"documents_metadata_title_lower_idx\").on(sql\`lower(metadata->>\\'title\\')\`)` - For case-insensitive search on metadata title.\n*   **Consideration:** An index on `(userId, contentType)` might be beneficial if this filtering combination is frequent.\n\n### `document_chunks` Table\n*   **Existing:**\n    *   `documentIdIdx: index(\"chunks_document_id_idx\").on(table.documentId)`\n    *   `chunkIndexIdx: index(\"chunks_chunk_index_idx\").on(table.chunkIndex)`\n    *   `embeddingIdx: index(\"document_chunks_embedding_idx\").using(\"hnsw\", table.embedding.op(\"vector_cosine_ops\"))` (HNSW for vector similarity)\n*   **Assessment:** Seems well-indexed for its purpose.\n\n### `conversations` Table\n*   **Existing:**\n    *   `userIdIdx: index(\"conversations_user_id_idx\").on(table.userId)`\n    *   `updatedAtIdx: index(\"conversations_updated_at_idx\").on(table.updatedAt)`\n*   **Added/Proposed (Task 14.2):**\n    *   `userIdUpdatedAtIdx: index(\"conversations_user_id_updated_at_idx\").on(table.userId, table.updatedAt)` - Composite index to optimize listing conversations for a user, sorted by update time.\n\n### `conversation_messages` Table\n*   **Existing:**\n    *   `conversationIdIdx: index(\"messages_conversation_id_idx\").on(table.conversationId)`\n    *   `createdAtIdx: index(\"messages_created_at_idx\").on(table.createdAt)`\n*   **Assessment:** Seems well-indexed for fetching messages for a conversation, sorted by creation time.\n\n### Other Tables\nIndexes on other tables (`document_processing_status`, `document_collections`, etc.) appear reasonable for their defined query patterns based on initial review.\n\n## Query Review Notes\n\n*   **`docmgmt/documents.ts` - `getDocuments`:**\n    *   The search functionality uses `LOWER(...) LIKE '%searchterm%'`. The added functional indexes on `lower(filename)`, `lower(originalName)`, and `lower(metadata->>'title')` are intended to support this. For true full-text search capabilities, PostgreSQL\'s `tsvector` and `tsquery` with a GIN or GiST index would be more advanced but also more complex to implement and maintain. The current approach with functional indexes on lowercased fields is a good first step for `LIKE` based searches.\n*   **Batch Operations:**\n    *   `docprocessing/processing.ts` - `storeChunksInDatabase`: Review if Drizzle ORM performs batch inserts by default when an array of values is passed to `db.insert().values()`. If not, explicitly use Drizzle\'s batching API if available for this operation to improve efficiency.\n\n## Monitoring and Iteration\n\n*   Database performance should be monitored in staging/production environments using appropriate tools (e.g., Encore\'s observability, database-specific monitoring).\n*   Query plans for slow queries should be analyzed.\n*   The indexing strategy should be revisited and refined based on actual usage patterns and performance data.\n\nThis document serves as an initial guide. Database optimization is an ongoing process. 